## Spring Framework / Java 경험
<br/>
<br/>
<br/>

### 엘포인트 포인트 환불 '법적제한계좌' 이슈

-   keyword
    -   트러블슈팅 및 해결
    -   커뮤니케이션
    -   협업
    -   꼼꼼

<hr/>


[커뮤니케이션 역량을 기반으로 ‘포인트 환불’ 기능의 트러블슈팅 해결]

 ‘롯데멤버스 엘포인트 및 엘페이 통합 채널 프로젝트’ 에서 포인트 환불 기능을 개발하던 중 EAI 인터페이스 규격에 맞게 VO를 만들고 값을 담아 EAI 통신 요청을 했는데, 통합테스트 도중 인터페이스 명세서에 기재되지 않는 ‘500’ 에러코드를 응답받았었습니다. 이는 자칫 여러 결함으로 이어질 수 있기 때문에, 이를 해결하기 위해 각 파트별 개발자와 함께 이슈에 대해 논의하며 로그 및 이슈 트래킹을 했던 경험이 있습니다. 
 포인트 환불 기능은 채널파트 서버에서 시작해서 페이파트에서 포인트비밀번호 검증을 끝낸 후, 업무파트로 넘어가서 사용자의 환불가능여부와 계좌성명체크를 진행합니다. 저는 순차적으로 파트별 개발자와 EAI 솔루션인 ‘EzMNA'와 서버 관리 시스템인 ’Hi-TAM'을 활용하여 로그 트래킹하며 Request Parameter 및 Header값 설정과 프록시 출발지/목적지 IP, 방화벽 설정 뿐 아니라 추가 이슈는 없는지 체크해나갔습니다. 그러던 중, 마지막 단계인 업무파트에서 환불받는 계좌를 성명조회하기 위해 FEP통신으로 세틀뱅크 서버에 계좌정보를 전달해주는데, 여기서 응답받은 값이 ‘법적제한계좌’ 라는 오류메세지 였습니다. 결국, 세틀뱅크 서버 담당자와 여러 차례 통화한 끝에 세틀뱅크 측에서 제공해준 테스트정보가 잘못된 정보인 것을 발견했고, 죄송하다는 말과 함께 세틀뱅크 측에서 다시 테스트 정보를 제공해주었습니다. 결국, ‘200’ 응답을 받았으며, 통합테스트 결함을 무사히 처리하여 이상없이 오픈할 수 있었습니다.

이를 통해 핀테크 서비스의 Backend는 대내외적으로 마치 거미줄처럼 다양하게 연관되어있기 때문에 트러블 슈팅이나 업무 처리에 있어 여러 파트 담당자와 커뮤니케이션이 필요하다는 것을 깨달았고, 이러한 트러블슈팅 및 프로젝트 수행 경험을 바탕으로 라인에서 다양한 파트와 커뮤니케이션하며 라인만의 서비스를 개발해나가겠습니다.
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>

### 롯데카드 로그인 체크 AOP 커스텀

-   keyword
    -   트러블슈팅 및 해결
    -   개선
    -   기술(깊이)
    -   롯데카드

<hr/>


[로그인 체크 및 개발의 관점을 변화시킨 AOP 개선]

'롯데카드 LOCA 2.0 프로젝트' 는 사용자의 로그인 정보를 별도 인터셉터를 커스텀해서 'coherence' 라는 NAM 솔루션을 활용해 세션에 UserEntity란 클래스 객체로 저장해둡니다. 그래서 로그인이 필수인 API의 메소드에서는 로그인 세션에 저장된 UserEntity 객체의 NULL 체크를 통해 비로그인시 로그인 화면으로 이동시키는 코드를 맨 앞에 작성합니다. 그런데 로그인이 필요한 API는 한 두개가 아닐 뿐더러, 카드 신청 프로세스 매 단계마다 로그인 체크가 필요한 경우도 있어 일일히 로그인 체크 코드를 작성해야하는 불필요한 작업과 코드 낭비 이슈가 있었습니다. 하지만, 개발자들 각자의 기능개발 일정이 있어 이를 개선하지 않았고, 제가 먼저 이 문제에 대해 얘기하고 개선하기 시작했습니다.
고민 끝에 어노테이션 하나로 호출 가능한 AOP를 사용하기로 결정했습니다. 이는 인터셉터 이후 호출되기 때문에 사전에 로그인 정보처리도 가능하고, 로그인 체크에 대한 모듈화로 공통화를 이룰 수 있어 단점을 줄인다고 판단했습니다.
우선, AOP 의존성(AspectJ + CGLib)을 추가한 뒤 Aspect 클래스를 만들고, 로그인 체크 메소드를 구현한 뒤 Before JoinPoint Annotation과 원하는 메소드와 패키지를 찾아 PointCut Annotation을 생성해 Aspect를 주입시켰습니다. 
이를 통해 반복적인 로그인 체크 코딩작업을 없앴고, 정회원 / 준회원 구분 등 로그인 체크 내의 새로운 로직도 한 번에 적용하며 추가 이슈를 빠르게 해결했습니다. 또한, PVO, RVO 로깅, 카드신청정보저장 등 각 공통작업을 다양한 JoinPoint Annotation을 활용하여 개발일정을 줄일 수 있었습니다. 
(Spring AOP vs AspectJ)
(간단하고, Bean 객체에만 한정(인터페이스를 구현한 클래스) vs 복잡하고(바이트코드 단위 AOP) 완전한 AOP. 인터페이스 구현한 클래스 외에도 가능)
(Proxy 기반 AOP vs CGLiB 기반 AOP -> Proxy 사용X)
(RunTime Weaving vs CompileTime Weaving)
Aspect: 여러 객체 또는 로직에 공통적으로 적용되는 공통 관심 사항을 주요 관심에서 분리시키는 것. 즉, 핵심에서 부가적인 기능을 분리시키는 것.
Aspect = Advice + PointCut
Advice = 공통 기능 각각의 로직
JoinPoint = Advice를 실행시킬 시점(Before, After, After Returning, After Throwing 등)
PointCut = Advice가 적용될 메소드 또는 범위(정규표현식)

- https://codevang.tistory.com/244
- https://bcho.tistory.com/226
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>

### 백엔드(Spring Framework) 실력을 쌓기 위해 노력한 3가지 방법

-   keyword
    -   개인공부 노력
    -   블로그
    -   토이프로젝트(트러블슈팅)
    -   개발서적

<hr/>


[개발 스킬 숙련도를 향상시키기 위한 세 가지 방법]

Java와 Spring framework를 활용한 백엔드 서버 개발 스킬을 향상시키기 위해 토이프로젝트, 개발관련 서적 공부, 블로그 포스팅이란 세 가지 방법을 수행했습니다.

 우선, 제가 기획한 토이프로젝트를 개발할 때 단순히 프로젝트 완성이 아니라 다양한 방법을 활용해 백엔드 개발 숙련도를 향상시키자는 목적으로 시작했었고, 이를 통해 좀 더 깊이있는 개발 스킬을 갖게 되었습니다. 이러한 대표적인 방법으로 ‘롯데정보통신’에서 수행했던 여러 프로젝트에서 사용했었던 Mybatis로 개발하지 않고, 그 대신에 JPA, Spring JDBC를 사용하며 Java로 DB와 연동하는 기술의 폭을 넓혔습니다. 또한, Naver Cloud Platform, AWS EC2를 생성해 프론트, API, DB서버로 활용하던 중 각각 도메인이 달라 CORS 이슈가 발생했었습니다. 이를 Filter를 만들어 dispatcher handling 전에 감지하거나 @EnableWebMvc를  활용해 webMvcConfigurer를 커스텀한 클래스에서 addCorsMappings 메소드를 오버라이딩 하는 방법, @CrossOrigin을 활용하는 방법 등 다방면으로 해당 이슈를 해결하려고 노력했습니다.

두 번째로 ‘실용주의 프로그래머’와 ‘소프트웨어 장인’ 과 같은 개발관련 서적을 읽으면서 ‘결합도와 응집도’, ‘재사용성과 가독성’ 등 SW개발 기본 원칙에 대해 공부하고 실전코딩의 팁과 노하우를 익히며 기초지식을 탄탄히 하는 데 노력하고 있습니다.

마지막으로, 블로그 포스팅을 통해 주력 분야인 Java 및 Spring framework를 활용한 서버 개발 역량을 다듬고 있습니다. 'Spring Boot', 'Swagger UI’, ‘lombok' 등 스스로 경험하고 공부한 것을 기록하고 있습니다. 이에 더해, 자료구조 및 알고리즘과 같은 CS지식과 개발 트러블 슈팅 및 해결방법에 대해서 정리하며 꾸준히 다시 읽으면서 기억해두려고 노력합니다.
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>

### 트렌트 기술 습득 방법

-   keyword
    -   얼리어답터
    -   트렌드 기술 습득
    -   개인공부 노력
    -   블로그
    -   토이프로젝트

<hr/>


[‘얼리어답터’ 개발자가 되기 위한 노력]
개인 기술 블로그 포스팅과 토이 프로젝트를 중심으로 'Spring boot 2.0', 'Vue.js 3.0', 'GraphQL' 등 최신 트렌트 기술을 익히고 있습니다. 

먼저, 블로그 포스팅을 통해 주력 분야인 Java/ Spring을 활용한 서버 개발 역량을 다듬고 있습니다. 사용성과 효율성을 증대시킬 수 있는 'Spring Boot', 업무 효용성을 증대시키는 'Swagger UI’등 스스로 경험하고 공부한 것을 기록하고 있습니다.

이외에 사이드 프로젝트의 주제를 구상하고, 메뉴 구조도, ERD, 아키텍쳐 설계 등 기획 산출물을 'Notion'에 정리했습니다. 이후 기존 REST API의 가장 큰 단점인 'Overfetching', 'Underfetching'으로 생기는 불필요한 메모리와 네트워크 낭비를 없애는 'GraphQL'을 'Spring boot 2.0’ 프레임워크 환경에 사용하여, 효율적인 API 통신 로직을 구현했습니다. 그리고, API 결과 데이터를 가공하여 'Vue.js 3.0'으로 SPA 구조 화면에 바인딩시키는 개발을 통해 프로젝트를 구체화하고 있습니다.
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>

### 롯데카드 티니패스  

-   keyword
    -   트러블슈팅 및 해결
    -   개선
    -   기술(깊이)
    -   롯데카드

<hr/>


상황> SELECT 값 조회(트랜잭션 적용)
    1-1) 존재하는 경우 -> counting + 1 후 update
    1-2) 존재하지 않는 경우 -> counting 1로 하는 값 insert

문제> Junit으로 ThreadPool을 만들고, Thread 동시성 테스트를 진행함. 
    1) 존재하는 값 조회 시 -> counting 더해지지 않고 무조건 counting 2(1 + 1)로 저장됨. -> 동시에 같은 SELECT 후 UPDATE를 진행하기 때문에 전부 counting 1로 READ 했다.
    2) 존재하지 않는 값 조회 시 -> 이미 존재하는 PK값 INSERT 시도로 Exception 발생.

원인 추적> 
    1) 동시성 문제. 어떤 Thread가 DB 데이터를 갱신해도 이를 다른 Thread가 인지하지 못하고 데이터를 UPDATE함  
    2) 1)과 동일하게 어떤 Thread에서 이미 INSERT한 값을 똑같이 다른 Thread에서도 INSERT하기 때문에 Duplicate PK Error 발생

해결>
    1) 동시성을 위한 Thread Lock?
        -> method 하나에만 lock(Synchronize)을 걸어도 객체 전체에 lock이 적용되기 때문에 Service를 Bean 싱글톤 객체로 사용하는 Spring에서는 치명적인 이슈가 될 것 같다.
        -> 여러 인스턴스의 서버를 가질 수 있기 때문에 로드밸런싱 되는 다른 인스턴스의 서버 애플리케이션에서 요청을 받으면 Thread Lock이 소용이 없어진다.
        -> 기각.
    2) DB Lock
        -> Transaction isolation level 적용
            -> 위 상황에 만족하는 고립 레벨이 없다.
            -> DB에도 MVCC를 적용해야하는데, h2는 1.14.200 버전을 사용해서 198버전 이상부터는 단순히 MVCC=true가 아닌 별도 설정이 필요하다.
            -> 해당 엔티티와 해당 SELECT에만 적용하고 싶다는 조건과 결이 다름
        -> SelectForUpdate repositry method와 비관적 잠금(PESSIMISTIC_WRITE) 적용
            -> 교착 상태 발생 가능성 높고, 나중에가면 하나의 레코드에 READ하는 Thread(트랜잭션)가 많을 수 있음.
            -> 위와 같은 이유로 비관적 잠금으로 인해 하나의 Thread가 Transaction할 동안 대기하는 것은 효율성이 매우 저하됨.
        -> 낙관적 잠금(Optimistic Lock), @Version 적용
            -> Update의 정합성을 위해 다른 트랜잭션이 Update시 버전 변경시키고, 만약 SELECT 당시 가져온 버전과 현재 DB에 반영된 버전이 다를 경우 예외 발생시키는 @Version 추가
            -> 이 때 트랜잭션을 종료시키는 것이 아니라 최신 버전의 값을 불러와서 counting 후 Update 시켜야 함
        -> @Retryable 어노테이션 활용
            -> Version 차이로 발생한 예외일 경우, 해당 트랜잭션 로직 재시도
            -> 정상적인 Update 확인
            -> InSERT는? -> 추가 개선점.


<br/>
<br/>
<br/>
<br/>
<br/>
<br/>

*작성중*
<br/>

### 롯데카드 KCB 인증 페이지 이슈

-   keyword
    -   트러블슈팅 및 해결
    -   커뮤니케이션
    -   협업
    -   꼼꼼

<hr/>


[ㄴㅇㅀ-]
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
